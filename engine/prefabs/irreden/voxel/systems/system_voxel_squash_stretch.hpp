#ifndef SYSTEM_VOXEL_SQUASH_STRETCH_H
#define SYSTEM_VOXEL_SQUASH_STRETCH_H

#include <cmath>

#include <irreden/ir_system.hpp>
#include <irreden/ir_math.hpp>
#include <irreden/ir_entity.hpp>
#include <irreden/ir_time.hpp>

#include <irreden/voxel/components/component_voxel_set.hpp>
#include <irreden/voxel/components/component_voxel_squash_stretch.hpp>
#include <irreden/update/components/component_velocity_3d.hpp>
#include <irreden/update/components/component_rhythmic_launch.hpp>
#include <irreden/update/components/component_contact_event.hpp>
#include <irreden/update/components/component_spring_platform.hpp>

using namespace IRComponents;
using namespace IRMath;

namespace IRSystem {

// Generated by cursor, not really ready to use.
// Inefficient, noisy. SHould probably use animation curves or something
// in the animation system itself.

template <> struct System<VOXEL_SQUASH_STRETCH> {
    static SystemId create() {
        return createSystem<C_VoxelSetNew, C_Velocity3D, C_VoxelSquashStretch>(
            "VoxelSquashStretch",
            [](IREntity::EntityId &entityId,
               C_VoxelSetNew &voxelSet,
               C_Velocity3D &velocity,
               C_VoxelSquashStretch &squashStretch) {
                if (voxelSet.numVoxels_ <= 0) {
                    return;
                }

                const float dt = IRTime::deltaTime(IRTime::UPDATE);
                const vec3 blockCenter = (vec3(voxelSet.size_) - vec3(1.0f)) * 0.5f;

                const float speed = length(velocity.velocity_);
                vec3 velDir = speed > 0.0001f
                    ? normalize(velocity.velocity_)
                    : vec3(0.0f, 0.0f, 0.0f);

                // Compute acceleration
                const vec3 accel = dt > 0.0001f
                    ? (velocity.velocity_ - squashStretch.prevVelocity_) / dt
                    : vec3(0.0f, 0.0f, 0.0f);
                const bool prevVelPrimed = length(squashStretch.prevVelocity_) > 0.0001f ||
                    length(velocity.velocity_) < 0.0001f;
                squashStretch.prevVelocity_ = velocity.velocity_;

                const float accelMag = length(accel);
                vec3 accelDir = accelMag > 0.0001f
                    ? normalize(accel)
                    : vec3(0.0f, 0.0f, 0.0f);

                // Optional smoothing
                float useSpeed = speed;
                vec3 useVelDir = velDir;
                if (squashStretch.smoothing_ > 0.0f) {
                    const float alpha = (1.0f - std::exp(-dt / squashStretch.smoothing_));
                    squashStretch.smoothedSpeed_ =
                        IRMath::mix(squashStretch.smoothedSpeed_, speed, alpha);
                    useSpeed = squashStretch.smoothedSpeed_;
                    if (speed > 0.0001f) {
                        squashStretch.smoothedVelDir_ =
                            normalize(IRMath::mix(squashStretch.smoothedVelDir_, velDir, alpha));
                        useVelDir = squashStretch.smoothedVelDir_;
                    } else {
                        useVelDir = squashStretch.smoothedVelDir_;
                    }
                }

                // Weights: stretch from velocity, squash from acceleration
                const float stretchWeight = squashStretch.stretchSpeedRef_ > 0.0f
                    ? IRMath::min(useSpeed / squashStretch.stretchSpeedRef_, 1.0f)
                    : 0.0f;
                const float squashWeightRaw = prevVelPrimed && squashStretch.squashAccelRef_ > 0.0f
                    ? IRMath::min(accelMag / squashStretch.squashAccelRef_, 1.0f)
                    : 0.0f;

                // Impact boost (event-driven)
                float squashWeight = squashWeightRaw;
                auto launchOpt = IREntity::getComponentOptional<C_RhythmicLaunch>(entityId);
                auto contactOpt = IREntity::getComponentOptional<C_ContactEvent>(entityId);

                if (launchOpt.has_value() && contactOpt.has_value()) {
                    const auto &contact = *contactOpt.value();
                    if (contact.entered_ && launchOpt.value()->grounded_) {
                        squashStretch.impactElapsedSec_ = 0.0f;
                    }
                    squashStretch.impactElapsedSec_ += dt;
                    if (squashStretch.impactBoost_ > 0.0f &&
                        squashStretch.impactDurationSec_ > 0.0f &&
                        squashStretch.impactElapsedSec_ < squashStretch.impactDurationSec_) {
                        const float t = squashStretch.impactElapsedSec_ /
                                       squashStretch.impactDurationSec_;
                        const float boost = squashStretch.impactBoost_ * (1.0f - t);
                        squashWeight = IRMath::min(squashWeight + boost, 1.0f);
                    }
                }

                // Spring bias: extra squash when platform is CATCHING (impact) or ANTICIPATING (load)
                if (squashStretch.useSpringBias_ && squashStretch.springBias_ > 0.0f &&
                    launchOpt.has_value()) {
                    const auto &launch = *launchOpt.value();
                    if (launch.grounded_ && launch.lastPlatformEntity_ != IREntity::kNullEntity &&
                        IREntity::entityExists(launch.lastPlatformEntity_)) {
                        auto springOpt = IREntity::getComponentOptional<C_SpringPlatform>(
                            launch.lastPlatformEntity_);
                        if (springOpt.has_value()) {
                            const auto state = springOpt.value()->state_;
                            if (state == SPRING_CATCHING || state == SPRING_ANTICIPATING) {
                                squashWeight = IRMath::min(
                                    squashWeight + squashStretch.springBias_, 1.0f);
                            }
                        }
                    }
                }

                // Blend: stretchWeight - squashWeight. Positive→stretch, Negative→squash
                const float blend = stretchWeight - squashWeight;
                vec3 deformAxis;
                float primaryScale;
                float perpScale;
                if (blend > 0.0001f) {
                    deformAxis = useVelDir;
                    primaryScale = 1.0f + squashStretch.stretchStrength_ * blend;
                    perpScale = squashStretch.volumePreserve_
                        ? 1.0f / std::sqrt(primaryScale)
                        : 1.0f - squashStretch.squashStrength_ * blend;
                } else if (blend < -0.0001f) {
                    deformAxis = accelDir;
                    primaryScale = 1.0f - squashStretch.squashStrength_ * (-blend);
                    perpScale = squashStretch.volumePreserve_
                        ? 1.0f / std::sqrt(IRMath::max(primaryScale, 0.01f))
                        : 1.0f;
                } else {
                    primaryScale = 1.0f;
                    perpScale = 1.0f;
                    deformAxis = vec3(0.0f, 0.0f, 0.0f);
                }

                // Event-driven impact burst (Z squash + XY expand)
                float impactScaleZ = 1.0f;
                float impactScaleXY = 1.0f;
                if (launchOpt.has_value() && contactOpt.has_value() &&
                    squashStretch.impactDurationSec_ > 0.0f &&
                    squashStretch.impactElapsedSec_ < squashStretch.impactDurationSec_) {
                    const float t = squashStretch.impactElapsedSec_ /
                                   squashStretch.impactDurationSec_;
                    impactScaleZ = IRMath::mix(
                        squashStretch.impactSquashZ_, 1.0f, t);
                    impactScaleXY = IRMath::mix(
                        squashStretch.impactExpandXY_, 1.0f, t);
                }

                const bool hasDeform = primaryScale > 1.0001f || primaryScale < 0.999f ||
                    impactScaleZ < 0.999f || impactScaleXY > 1.0001f;

                if (!hasDeform) {
                    for (int i = 0; i < voxelSet.numVoxels_; i++) {
                        voxelSet.positionOffsets_[i].pos_ = vec3(0.0f);
                    }
                    return;
                }

                const int safeCount = static_cast<int>(IRMath::min(
                    static_cast<size_t>(voxelSet.numVoxels_),
                    IRMath::min(
                        voxelSet.positions_.size(),
                        voxelSet.positionOffsets_.size()
                    )
                ));

                const float maxDistFromCenter =
                    length(vec3(voxelSet.size_) - vec3(1.0f)) * 0.5f;
                const float maxDistSq = maxDistFromCenter > 0.0001f
                    ? maxDistFromCenter * maxDistFromCenter
                    : 1.0f;

                for (int i = 0; i < safeCount; i++) {
                    const vec3 local = voxelSet.positions_[i].pos_;
                    const vec3 fromCenter = local - blockCenter;

                    vec3 scaled;
                    if (length(deformAxis) > 0.0001f) {
                        const float along = IRMath::dot(fromCenter, deformAxis);
                        const vec3 perp = fromCenter - deformAxis * along;
                        scaled = deformAxis * (along * primaryScale) + perp * perpScale;
                    } else {
                        scaled = fromCenter;
                    }

                    const float distSq = IRMath::dot(fromCenter, fromCenter);
                    const float falloff = 1.0f -
                        squashStretch.roundness_ *
                            IRMath::clamp(distSq / maxDistSq, 0.0f, 1.0f);
                    scaled = fromCenter + (scaled - fromCenter) * falloff;

                    if (impactScaleZ < 0.999f) {
                        scaled.z += fromCenter.z * (impactScaleZ - 1.0f) * falloff;
                    }
                    if (impactScaleXY > 1.0001f) {
                        scaled.x += fromCenter.x * (impactScaleXY - 1.0f) * falloff;
                        scaled.y += fromCenter.y * (impactScaleXY - 1.0f) * falloff;
                    }

                    voxelSet.positionOffsets_[i].pos_ = scaled - fromCenter;
                }
            }
        );
    }
};

} // namespace IRSystem

#endif /* SYSTEM_VOXEL_SQUASH_STRETCH_H */
