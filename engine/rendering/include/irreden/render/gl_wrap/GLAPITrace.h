/**GLAPITrace.h file generated by GetGLAPI.py
 * Script created by Sergey Kosarevsky sk@linderdaum.com
 * Modified by Evin Killian jakildev@gmail.com for the Irreden Game Engine.
 */
#include <string>
#include <inttypes.h>
#include <irreden/ir_profiling.hpp>

namespace
{
	GL4API apiHook;
} // namespace

using PFNGETGLPROC = void* (const char*);

#define E2S( en ) Enum2String( en ).c_str()
extern std::string Enum2String( GLenum e );

void GLTracer_glCullFace(GLenum mode)
{
	IRProfile::glLogDebug("glCullFace({})", E2S(mode));
	apiHook.glCullFace(mode);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glPolygonMode(GLenum face, GLenum mode)
{
	IRProfile::glLogDebug("glPolygonMode({}, {})", E2S(face), E2S(mode));
	apiHook.glPolygonMode(face, mode);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
	IRProfile::glLogDebug("glScissor({}, {}, {}, {})", x, y, width, height);
	apiHook.glScissor(x, y, width, height);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
	IRProfile::glLogDebug("glTexParameterf({}, {}, {})", E2S(target), E2S(pname), param);
	apiHook.glTexParameterf(target, pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params)
{
	IRProfile::glLogDebug("glTexParameterfv({}, {}, {})", E2S(target), E2S(pname), (const void*)(params));
	apiHook.glTexParameterfv(target, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
	IRProfile::glLogDebug("glTexParameteri({}, {}, {})", E2S(target), E2S(pname), param);
	apiHook.glTexParameteri(target, pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTexParameteriv(GLenum target, GLenum pname, const GLint* params)
{
	IRProfile::glLogDebug("glTexParameteriv({}, {}, {})", E2S(target), E2S(pname), (const void*)(params));
	apiHook.glTexParameteriv(target, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels)
{
	IRProfile::glLogDebug("glTexImage2D({}, {}, {}, {}, {}, {}, {}, {}, {})", E2S(target), level, internalformat, width, height, border, E2S(format), E2S(type), pixels);
	apiHook.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glClear(GLbitfield mask)
{
	IRProfile::glLogDebug("glClear({})", (unsigned int)(mask));
	apiHook.glClear(mask);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	IRProfile::glLogDebug("glClearColor({}, {}, {}, {})", red, green, blue, alpha);
	apiHook.glClearColor(red, green, blue, alpha);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glClearStencil(GLint s)
{
	IRProfile::glLogDebug("glClearStencil({})", s);
	apiHook.glClearStencil(s);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glClearDepth(GLdouble depth)
{
	IRProfile::glLogDebug("glClearDepth({})", depth);
	apiHook.glClearDepth(depth);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
	IRProfile::glLogDebug("glColorMask({}, {}, {}, {})", (unsigned int)(red), (unsigned int)(green), (unsigned int)(blue), (unsigned int)(alpha));
	apiHook.glColorMask(red, green, blue, alpha);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDepthMask(GLboolean flag)
{
	IRProfile::glLogDebug("glDepthMask({})", (unsigned int)(flag));
	apiHook.glDepthMask(flag);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDisable(GLenum cap)
{
	IRProfile::glLogDebug("glDisable({})", E2S(cap));
	apiHook.glDisable(cap);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glEnable(GLenum cap)
{
	IRProfile::glLogDebug("glEnable({})", E2S(cap));
	apiHook.glEnable(cap);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glFinish()
{
	IRProfile::glLogDebug("glFinish()\n");
	apiHook.glFinish();
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glFlush()
{
	IRProfile::glLogDebug("glFlush()\n");
	apiHook.glFlush();
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBlendFunc(GLenum sfactor, GLenum dfactor)
{
	IRProfile::glLogDebug("glBlendFunc({}, {})", E2S(sfactor), E2S(dfactor));
	apiHook.glBlendFunc(sfactor, dfactor);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDepthFunc(GLenum func)
{
	IRProfile::glLogDebug("glDepthFunc({})", E2S(func));
	apiHook.glDepthFunc(func);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glPixelStorei(GLenum pname, GLint param)
{
	IRProfile::glLogDebug("glPixelStorei({}, {})", E2S(pname), param);
	apiHook.glPixelStorei(pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glReadBuffer(GLenum src)
{
	IRProfile::glLogDebug("glReadBuffer({})", E2S(src));
	apiHook.glReadBuffer(src);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels)
{
	IRProfile::glLogDebug("glReadPixels({}, {}, {}, {}, {}, {}, {})", x, y, width, height, E2S(format), E2S(type), pixels);
	apiHook.glReadPixels(x, y, width, height, format, type, pixels);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

GLenum GLTracer_glGetError()
{
	IRProfile::glLogDebug("glGetError()\n");
	GLenum const r = apiHook.glGetError();
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

void GLTracer_glGetIntegerv(GLenum pname, GLint* data)
{
	IRProfile::glLogDebug("glGetIntegerv({}, {})", E2S(pname), (void*)(data));
	apiHook.glGetIntegerv(pname, data);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

const GLubyte* GLTracer_glGetString(GLenum name)
{
	IRProfile::glLogDebug("glGetString({})", E2S(name));
	const GLubyte* const r = apiHook.glGetString(name);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

void GLTracer_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void* pixels)
{
	IRProfile::glLogDebug("glGetTexImage({}, {}, {}, {}, {})", E2S(target), level, E2S(format), E2S(type), pixels);
	apiHook.glGetTexImage(target, level, format, type, pixels);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params)
{
	IRProfile::glLogDebug("glGetTexLevelParameteriv({}, {}, {}, {})", E2S(target), level, E2S(pname), (void*)(params));
	apiHook.glGetTexLevelParameteriv(target, level, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
	IRProfile::glLogDebug("glViewport({}, {}, {}, {})", x, y, width, height);
	apiHook.glViewport(x, y, width, height);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
	IRProfile::glLogDebug("glDrawArrays({}, {}, {})", E2S(mode), first, count);
	apiHook.glDrawArrays(mode, first, count);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDrawElements(GLenum mode, GLsizei count, GLenum type, const void* indices)
{
	IRProfile::glLogDebug("glDrawElements({}, {}, {}, {})", E2S(mode), count, E2S(type), indices);
	apiHook.glDrawElements(mode, count, type, indices);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels)
{
	IRProfile::glLogDebug("glTexSubImage2D({}, {}, {}, {}, {}, {}, {}, {}, {})", E2S(target), level, xoffset, yoffset, width, height, E2S(format), E2S(type), pixels);
	apiHook.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDeleteTextures(GLsizei n, const GLuint* textures)
{
	IRProfile::glLogDebug("glDeleteTextures({}, {})", n, (const void*)(textures));
	apiHook.glDeleteTextures(n, textures);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGenTextures(GLsizei n, GLuint* textures)
{
	IRProfile::glLogDebug("glGenTextures({}, {})", n, (void*)(textures));
	apiHook.glGenTextures(n, textures);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels)
{
	IRProfile::glLogDebug("glTexImage3D({}, {}, {}, {}, {}, {}, {}, {}, {}, {})", E2S(target), level, internalformat, width, height, depth, border, E2S(format), E2S(type), pixels);
	apiHook.glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glActiveTexture(GLenum texture)
{
	IRProfile::glLogDebug("glActiveTexture({})", E2S(texture));
	apiHook.glActiveTexture(texture);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data)
{
	IRProfile::glLogDebug("glCompressedTexImage3D({}, {}, {}, {}, {}, {}, {}, {}, {})", E2S(target), level, E2S(internalformat), width, height, depth, border, imageSize, data);
	apiHook.glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data)
{
	IRProfile::glLogDebug("glCompressedTexImage2D({}, {}, {}, {}, {}, {}, {}, {})", E2S(target), level, E2S(internalformat), width, height, border, imageSize, data);
	apiHook.glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetCompressedTexImage(GLenum target, GLint level, void* img)
{
	IRProfile::glLogDebug("glGetCompressedTexImage({}, {}, {})", E2S(target), level, img);
	apiHook.glGetCompressedTexImage(target, level, img);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGenQueries(GLsizei n, GLuint* ids)
{
	IRProfile::glLogDebug("glGenQueries({}, {})", n, (void*)(ids));
	apiHook.glGenQueries(n, ids);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDeleteQueries(GLsizei n, const GLuint* ids)
{
	IRProfile::glLogDebug("glDeleteQueries({}, {})", n, (const void*)(ids));
	apiHook.glDeleteQueries(n, ids);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBeginQuery(GLenum target, GLuint id)
{
	IRProfile::glLogDebug("glBeginQuery({}, {})", E2S(target), id);
	apiHook.glBeginQuery(target, id);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glEndQuery(GLenum target)
{
	IRProfile::glLogDebug("glEndQuery({})", E2S(target));
	apiHook.glEndQuery(target);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetQueryObjectiv(GLuint id, GLenum pname, GLint* params)
{
	IRProfile::glLogDebug("glGetQueryObjectiv({}, {}, {})", id, E2S(pname), (void*)(params));
	apiHook.glGetQueryObjectiv(id, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBindBuffer(GLenum target, GLuint buffer)
{
	IRProfile::glLogDebug("glBindBuffer({}, {})", E2S(target), buffer);
	apiHook.glBindBuffer(target, buffer);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDeleteBuffers(GLsizei n, const GLuint* buffers)
{
	IRProfile::glLogDebug("glDeleteBuffers({}, {})", n, (const void*)(buffers));
	apiHook.glDeleteBuffers(n, buffers);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGenBuffers(GLsizei n, GLuint* buffers)
{
	IRProfile::glLogDebug("glGenBuffers({}, {})", n, (void*)(buffers));
	apiHook.glGenBuffers(n, buffers);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBufferData(GLenum target, GLsizeiptr size, const void* data, GLenum usage)
{
	IRProfile::glLogDebug("glBufferData({}, {}, {}, {})", E2S(target), size, data, E2S(usage));
	apiHook.glBufferData(target, size, data, usage);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void* data)
{
	IRProfile::glLogDebug("glBufferSubData({}, {}, {}, {})", E2S(target), offset, size, data);
	apiHook.glBufferSubData(target, offset, size, data);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDrawBuffers(GLsizei n, const GLenum* bufs)
{
	IRProfile::glLogDebug("glDrawBuffers({}, {})", n, (const void*)(bufs));
	apiHook.glDrawBuffers(n, bufs);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glAttachShader(GLuint program, GLuint shader)
{
	IRProfile::glLogDebug("glAttachShader({}, {})", program, shader);
	apiHook.glAttachShader(program, shader);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBindAttribLocation(GLuint program, GLuint index, const GLchar* name)
{
	IRProfile::glLogDebug("glBindAttribLocation({}, {}, {})", program, index, (const void*)(name));
	apiHook.glBindAttribLocation(program, index, name);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCompileShader(GLuint shader)
{
	IRProfile::glLogDebug("glCompileShader({})", shader);
	apiHook.glCompileShader(shader);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

GLuint GLTracer_glCreateProgram()
{
	IRProfile::glLogDebug("glCreateProgram()\n");
	GLuint const r = apiHook.glCreateProgram();
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

GLuint GLTracer_glCreateShader(GLenum type)
{
	IRProfile::glLogDebug("glCreateShader({})", E2S(type));
	GLuint const r = apiHook.glCreateShader(type);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

void GLTracer_glDeleteProgram(GLuint program)
{
	IRProfile::glLogDebug("glDeleteProgram({})", program);
	apiHook.glDeleteProgram(program);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDeleteShader(GLuint shader)
{
	IRProfile::glLogDebug("glDeleteShader({})", shader);
	apiHook.glDeleteShader(shader);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDisableVertexAttribArray(GLuint index)
{
	IRProfile::glLogDebug("glDisableVertexAttribArray({})", index);
	apiHook.glDisableVertexAttribArray(index);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glEnableVertexAttribArray(GLuint index)
{
	IRProfile::glLogDebug("glEnableVertexAttribArray({})", index);
	apiHook.glEnableVertexAttribArray(index);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
{
	IRProfile::glLogDebug("glGetActiveAttrib({}, {}, {}, {}, {}, {}, {})", program, index, bufSize, (void*)(length), (void*)(size), (void*)(type), (void*)(name));
	apiHook.glGetActiveAttrib(program, index, bufSize, length, size, type, name);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
{
	IRProfile::glLogDebug("glGetActiveUniform({}, {}, {}, {}, {}, {}, {})", program, index, bufSize, (void*)(length), (void*)(size), (void*)(type), (void*)(name));
	apiHook.glGetActiveUniform(program, index, bufSize, length, size, type, name);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

GLint GLTracer_glGetAttribLocation(GLuint program, const GLchar* name)
{
	IRProfile::glLogDebug("glGetAttribLocation({}, {})", program, (const void*)(name));
	GLint const r = apiHook.glGetAttribLocation(program, name);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

void GLTracer_glGetProgramiv(GLuint program, GLenum pname, GLint* params)
{
	IRProfile::glLogDebug("glGetProgramiv({}, {}, {})", program, E2S(pname), (void*)(params));
	apiHook.glGetProgramiv(program, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog)
{
	IRProfile::glLogDebug("glGetProgramInfoLog({}, {}, {}, {})", program, bufSize, (void*)(length), (void*)(infoLog));
	apiHook.glGetProgramInfoLog(program, bufSize, length, infoLog);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetShaderiv(GLuint shader, GLenum pname, GLint* params)
{
	IRProfile::glLogDebug("glGetShaderiv({}, {}, {})", shader, E2S(pname), (void*)(params));
	apiHook.glGetShaderiv(shader, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog)
{
	IRProfile::glLogDebug("glGetShaderInfoLog({}, {}, {}, {})", shader, bufSize, (void*)(length), (void*)(infoLog));
	apiHook.glGetShaderInfoLog(shader, bufSize, length, infoLog);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

GLint GLTracer_glGetUniformLocation(GLuint program, const GLchar* name)
{
	IRProfile::glLogDebug("glGetUniformLocation({}, {})", program, (const void*)(name));
	GLint const r = apiHook.glGetUniformLocation(program, name);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

GLboolean GLTracer_glIsProgram(GLuint program)
{
	IRProfile::glLogDebug("glIsProgram({})", program);
	GLboolean const r = apiHook.glIsProgram(program);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

GLboolean GLTracer_glIsShader(GLuint shader)
{
	IRProfile::glLogDebug("glIsShader({})", shader);
	GLboolean const r = apiHook.glIsShader(shader);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

void GLTracer_glLinkProgram(GLuint program)
{
	IRProfile::glLogDebug("glLinkProgram({})", program);
	apiHook.glLinkProgram(program);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glShaderSource(GLuint shader, GLsizei count, const GLchar* const* string, const GLint* length)
{
	IRProfile::glLogDebug("glShaderSource({}, {}, {}, {})", shader, count, (const void*)(string), (const void*)(length));
	apiHook.glShaderSource(shader, count, string, length);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glUseProgram(GLuint program)
{
	IRProfile::glLogDebug("glUseProgram({})", program);
	apiHook.glUseProgram(program);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glUniform1f(GLint location, GLfloat v0)
{
	IRProfile::glLogDebug("glUniform1f({}, {})", location, v0);
	apiHook.glUniform1f(location, v0);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glUniform1i(GLint location, GLint v0)
{
	IRProfile::glLogDebug("glUniform1i({}, {})", location, v0);
	apiHook.glUniform1i(location, v0);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glUniform1fv(GLint location, GLsizei count, const GLfloat* value)
{
	IRProfile::glLogDebug("glUniform1fv({}, {}, {})", location, count, (const void*)(value));
	apiHook.glUniform1fv(location, count, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glUniform3fv(GLint location, GLsizei count, const GLfloat* value)
{
	IRProfile::glLogDebug("glUniform3fv({}, {}, {})", location, count, (const void*)(value));
	apiHook.glUniform3fv(location, count, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glUniform4fv(GLint location, GLsizei count, const GLfloat* value)
{
	IRProfile::glLogDebug("glUniform4fv({}, {}, {})", location, count, (const void*)(value));
	apiHook.glUniform4fv(location, count, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glUniform1iv(GLint location, GLsizei count, const GLint* value)
{
	IRProfile::glLogDebug("glUniform1iv({}, {}, {})", location, count, (const void*)(value));
	apiHook.glUniform1iv(location, count, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	IRProfile::glLogDebug("glUniformMatrix3fv({}, {}, {}, {})", location, count, (unsigned int)(transpose), (const void*)(value));
	apiHook.glUniformMatrix3fv(location, count, transpose, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	IRProfile::glLogDebug("glUniformMatrix4fv({}, {}, {}, {})", location, count, (unsigned int)(transpose), (const void*)(value));
	apiHook.glUniformMatrix4fv(location, count, transpose, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glValidateProgram(GLuint program)
{
	IRProfile::glLogDebug("glValidateProgram({})", program);
	apiHook.glValidateProgram(program);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer)
{
	IRProfile::glLogDebug("glVertexAttribPointer({}, {}, {}, {}, {}, {})", index, size, E2S(type), (unsigned int)(normalized), stride, pointer);
	apiHook.glVertexAttribPointer(index, size, type, normalized, stride, pointer);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glEnablei(GLenum target, GLuint index)
{
	IRProfile::glLogDebug("glEnablei({}, {})", E2S(target), index);
	apiHook.glEnablei(target, index);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDisablei(GLenum target, GLuint index)
{
	IRProfile::glLogDebug("glDisablei({}, {})", E2S(target), index);
	apiHook.glDisablei(target, index);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
	IRProfile::glLogDebug("glBindBufferRange({}, {}, {}, {}, {})", E2S(target), index, buffer, offset, size);
	apiHook.glBindBufferRange(target, index, buffer, offset, size);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
	IRProfile::glLogDebug("glBindBufferBase({}, {}, {})", E2S(target), index, buffer);
	apiHook.glBindBufferBase(target, index, buffer);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBindFragDataLocation(GLuint program, GLuint color, const GLchar* name)
{
	IRProfile::glLogDebug("glBindFragDataLocation({}, {}, {})", program, color, (const void*)(name));
	apiHook.glBindFragDataLocation(program, color, name);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

const GLubyte* GLTracer_glGetStringi(GLenum name, GLuint index)
{
	IRProfile::glLogDebug("glGetStringi({}, {})", E2S(name), index);
	const GLubyte* const r = apiHook.glGetStringi(name, index);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

void GLTracer_glBindFramebuffer(GLenum target, GLuint framebuffer)
{
	IRProfile::glLogDebug("glBindFramebuffer({}, {})", E2S(target), framebuffer);
	apiHook.glBindFramebuffer(target, framebuffer);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDeleteFramebuffers(GLsizei n, const GLuint* framebuffers)
{
	IRProfile::glLogDebug("glDeleteFramebuffers({}, {})", n, (const void*)(framebuffers));
	apiHook.glDeleteFramebuffers(n, framebuffers);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGenFramebuffers(GLsizei n, GLuint* framebuffers)
{
	IRProfile::glLogDebug("glGenFramebuffers({}, {})", n, (void*)(framebuffers));
	apiHook.glGenFramebuffers(n, framebuffers);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

GLenum GLTracer_glCheckFramebufferStatus(GLenum target)
{
	IRProfile::glLogDebug("glCheckFramebufferStatus({})", E2S(target));
	GLenum const r = apiHook.glCheckFramebufferStatus(target);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

void GLTracer_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	IRProfile::glLogDebug("glFramebufferTexture2D({}, {}, {}, {}, {})", E2S(target), E2S(attachment), E2S(textarget), texture, level);
	apiHook.glFramebufferTexture2D(target, attachment, textarget, texture, level);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
	IRProfile::glLogDebug("glFramebufferTexture3D({}, {}, {}, {}, {}, {})", E2S(target), E2S(attachment), E2S(textarget), texture, level, zoffset);
	apiHook.glFramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGenerateMipmap(GLenum target)
{
	IRProfile::glLogDebug("glGenerateMipmap({})", E2S(target));
	apiHook.glGenerateMipmap(target);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBindVertexArray(GLuint array)
{
	IRProfile::glLogDebug("glBindVertexArray({})", array);
	apiHook.glBindVertexArray(array);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDeleteVertexArrays(GLsizei n, const GLuint* arrays)
{
	IRProfile::glLogDebug("glDeleteVertexArrays({}, {})", n, (const void*)(arrays));
	apiHook.glDeleteVertexArrays(n, arrays);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGenVertexArrays(GLsizei n, GLuint* arrays)
{
	IRProfile::glLogDebug("glGenVertexArrays({}, {})", n, (void*)(arrays));
	apiHook.glGenVertexArrays(n, arrays);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount)
{
	IRProfile::glLogDebug("glDrawArraysInstanced({}, {}, {}, {})", E2S(mode), first, count, instancecount);
	apiHook.glDrawArraysInstanced(mode, first, count, instancecount);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount)
{
	IRProfile::glLogDebug("glDrawElementsInstanced({}, {}, {}, {}, {})", E2S(mode), count, E2S(type), indices, instancecount);
	apiHook.glDrawElementsInstanced(mode, count, type, indices, instancecount);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params)
{
	IRProfile::glLogDebug("glGetActiveUniformBlockiv({}, {}, {}, {})", program, uniformBlockIndex, E2S(pname), (void*)(params));
	apiHook.glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
	IRProfile::glLogDebug("glUniformBlockBinding({}, {}, {})", program, uniformBlockIndex, uniformBlockBinding);
	apiHook.glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64* params)
{
	IRProfile::glLogDebug("glGetQueryObjectui64v({}, {}, {})", id, E2S(pname), (void*)(params));
	apiHook.glGetQueryObjectui64v(id, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

GLint GLTracer_glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar* name)
{
	IRProfile::glLogDebug("glGetSubroutineUniformLocation({}, {}, {})", program, E2S(shadertype), (const void*)(name));
	GLint const r = apiHook.glGetSubroutineUniformLocation(program, shadertype, name);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

GLuint GLTracer_glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar* name)
{
	IRProfile::glLogDebug("glGetSubroutineIndex({}, {}, {})", program, E2S(shadertype), (const void*)(name));
	GLuint const r = apiHook.glGetSubroutineIndex(program, shadertype, name);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

void GLTracer_glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values)
{
	IRProfile::glLogDebug("glGetActiveSubroutineUniformiv({}, {}, {}, {}, {})", program, E2S(shadertype), index, E2S(pname), (void*)(values));
	apiHook.glGetActiveSubroutineUniformiv(program, shadertype, index, pname, values);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar* name)
{
	IRProfile::glLogDebug("glGetActiveSubroutineName({}, {}, {}, {}, {}, {})", program, E2S(shadertype), index, bufsize, (void*)(length), (void*)(name));
	apiHook.glGetActiveSubroutineName(program, shadertype, index, bufsize, length, name);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint* indices)
{
	IRProfile::glLogDebug("glUniformSubroutinesuiv({}, {}, {})", E2S(shadertype), count, (const void*)(indices));
	apiHook.glUniformSubroutinesuiv(shadertype, count, indices);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint* values)
{
	IRProfile::glLogDebug("glGetProgramStageiv({}, {}, {}, {})", program, E2S(shadertype), E2S(pname), (void*)(values));
	apiHook.glGetProgramStageiv(program, shadertype, pname, values);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glPatchParameteri(GLenum pname, GLint value)
{
	IRProfile::glLogDebug("glPatchParameteri({}, {})", E2S(pname), value);
	apiHook.glPatchParameteri(pname, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary)
{
	IRProfile::glLogDebug("glGetProgramBinary({}, {}, {}, {}, {})", program, bufSize, (void*)(length), (void*)(binaryFormat), binary);
	apiHook.glGetProgramBinary(program, bufSize, length, binaryFormat, binary);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glProgramBinary(GLuint program, GLenum binaryFormat, const void* binary, GLsizei length)
{
	IRProfile::glLogDebug("glProgramBinary({}, {}, {}, {})", program, E2S(binaryFormat), binary, length);
	apiHook.glProgramBinary(program, binaryFormat, binary, length);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glProgramParameteri(GLuint program, GLenum pname, GLint value)
{
	IRProfile::glLogDebug("glProgramParameteri({}, {}, {})", program, E2S(pname), value);
	apiHook.glProgramParameteri(program, pname, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glProgramUniform1i(GLuint program, GLint location, GLint v0)
{
	IRProfile::glLogDebug("glProgramUniform1i({}, {}, {})", program, location, v0);
	apiHook.glProgramUniform1i(program, location, v0);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glProgramUniform1f(GLuint program, GLint location, GLfloat v0)
{
	IRProfile::glLogDebug("glProgramUniform1f({}, {}, {})", program, location, v0);
	apiHook.glProgramUniform1f(program, location, v0);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint* value)
{
	IRProfile::glLogDebug("glProgramUniform2iv({}, {}, {}, {})", program, location, count, (const void*)(value));
	apiHook.glProgramUniform2iv(program, location, count, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat* value)
{
	IRProfile::glLogDebug("glProgramUniform2fv({}, {}, {}, {})", program, location, count, (const void*)(value));
	apiHook.glProgramUniform2fv(program, location, count, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint* value)
{
	IRProfile::glLogDebug("glProgramUniform3iv({}, {}, {}, {})", program, location, count, (const void*)(value));
	apiHook.glProgramUniform3iv(program, location, count, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat* value)
{
	IRProfile::glLogDebug("glProgramUniform3fv({}, {}, {}, {})", program, location, count, (const void*)(value));
	apiHook.glProgramUniform3fv(program, location, count, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint* value)
{
	IRProfile::glLogDebug("glProgramUniform4iv({}, {}, {}, {})", program, location, count, (const void*)(value));
	apiHook.glProgramUniform4iv(program, location, count, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat* value)
{
	IRProfile::glLogDebug("glProgramUniform4fv({}, {}, {}, {})", program, location, count, (const void*)(value));
	apiHook.glProgramUniform4fv(program, location, count, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBindTextures(GLuint first, GLsizei count, const GLuint* textures)
{
	IRProfile::glLogDebug("glBindTextures({}, {}, {})", first, count, (const void*)(textures));
	apiHook.glBindTextures(first, count, textures);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCreateTransformFeedbacks(GLsizei n, GLuint* ids)
{
	IRProfile::glLogDebug("glCreateTransformFeedbacks({}, {})", n, (void*)(ids));
	apiHook.glCreateTransformFeedbacks(n, ids);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer)
{
	IRProfile::glLogDebug("glTransformFeedbackBufferBase({}, {}, {})", xfb, index, buffer);
	apiHook.glTransformFeedbackBufferBase(xfb, index, buffer);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizei size)
{
	IRProfile::glLogDebug("glTransformFeedbackBufferRange({}, {}, {}, {}, {})", xfb, index, buffer, offset, size);
	apiHook.glTransformFeedbackBufferRange(xfb, index, buffer, offset, size);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint* param)
{
	IRProfile::glLogDebug("glGetTransformFeedbackiv({}, {}, {})", xfb, E2S(pname), (void*)(param));
	apiHook.glGetTransformFeedbackiv(xfb, pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint* param)
{
	IRProfile::glLogDebug("glGetTransformFeedbacki_v({}, {}, {}, {})", xfb, E2S(pname), index, (void*)(param));
	apiHook.glGetTransformFeedbacki_v(xfb, pname, index, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64* param)
{
	IRProfile::glLogDebug("glGetTransformFeedbacki64_v({}, {}, {}, {})", xfb, E2S(pname), index, (void*)(param));
	apiHook.glGetTransformFeedbacki64_v(xfb, pname, index, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCreateBuffers(GLsizei n, GLuint* buffers)
{
	IRProfile::glLogDebug("glCreateBuffers({}, {})", n, (void*)(buffers));
	apiHook.glCreateBuffers(n, buffers);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glNamedBufferStorage(GLuint buffer, GLsizei size, const void* data, GLbitfield flags)
{
	IRProfile::glLogDebug("glNamedBufferStorage({}, {}, {}, {})", buffer, size, data, (unsigned int)(flags));
	apiHook.glNamedBufferStorage(buffer, size, data, flags);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glNamedBufferData(GLuint buffer, GLsizei size, const void* data, GLenum usage)
{
	IRProfile::glLogDebug("glNamedBufferData({}, {}, {}, {})", buffer, size, data, E2S(usage));
	apiHook.glNamedBufferData(buffer, size, data, usage);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizei size, const void* data)
{
	IRProfile::glLogDebug("glNamedBufferSubData({}, {}, {}, {})", buffer, offset, size, data);
	apiHook.glNamedBufferSubData(buffer, offset, size, data);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizei size)
{
	IRProfile::glLogDebug("glCopyNamedBufferSubData({}, {}, {}, {}, {})", readBuffer, writeBuffer, readOffset, writeOffset, size);
	apiHook.glCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void* data)
{
	IRProfile::glLogDebug("glClearNamedBufferData({}, {}, {}, {}, {})", buffer, E2S(internalformat), E2S(format), E2S(type), data);
	apiHook.glClearNamedBufferData(buffer, internalformat, format, type, data);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizei size, GLenum format, GLenum type, const void* data)
{
	IRProfile::glLogDebug("glClearNamedBufferSubData({}, {}, {}, {}, {}, {}, {})", buffer, E2S(internalformat), offset, size, E2S(format), E2S(type), data);
	apiHook.glClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void* GLTracer_glMapNamedBuffer(GLuint buffer, GLenum access)
{
	IRProfile::glLogDebug("glMapNamedBuffer({}, {})", buffer, E2S(access));
	void* const r = apiHook.glMapNamedBuffer(buffer, access);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

void* GLTracer_glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizei length, GLbitfield access)
{
	IRProfile::glLogDebug("glMapNamedBufferRange({}, {}, {}, {})", buffer, offset, length, (unsigned int)(access));
	void* const r = apiHook.glMapNamedBufferRange(buffer, offset, length, access);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

GLboolean GLTracer_glUnmapNamedBuffer(GLuint buffer)
{
	IRProfile::glLogDebug("glUnmapNamedBuffer({})", buffer);
	GLboolean const r = apiHook.glUnmapNamedBuffer(buffer);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

void GLTracer_glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizei length)
{
	IRProfile::glLogDebug("glFlushMappedNamedBufferRange({}, {}, {})", buffer, offset, length);
	apiHook.glFlushMappedNamedBufferRange(buffer, offset, length);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint* params)
{
	IRProfile::glLogDebug("glGetNamedBufferParameteriv({}, {}, {})", buffer, E2S(pname), (void*)(params));
	apiHook.glGetNamedBufferParameteriv(buffer, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64* params)
{
	IRProfile::glLogDebug("glGetNamedBufferParameteri64v({}, {}, {})", buffer, E2S(pname), (void*)(params));
	apiHook.glGetNamedBufferParameteri64v(buffer, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void** params)
{
	IRProfile::glLogDebug("glGetNamedBufferPointerv({}, {}, {})", buffer, E2S(pname), (void*)(params));
	apiHook.glGetNamedBufferPointerv(buffer, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizei size, void* data)
{
	IRProfile::glLogDebug("glGetNamedBufferSubData({}, {}, {}, {})", buffer, offset, size, data);
	apiHook.glGetNamedBufferSubData(buffer, offset, size, data);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCreateFramebuffers(GLsizei n, GLuint* framebuffers)
{
	IRProfile::glLogDebug("glCreateFramebuffers({}, {})", n, (void*)(framebuffers));
	apiHook.glCreateFramebuffers(n, framebuffers);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
	IRProfile::glLogDebug("glNamedFramebufferRenderbuffer({}, {}, {}, {})", framebuffer, E2S(attachment), E2S(renderbuffertarget), renderbuffer);
	apiHook.glNamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param)
{
	IRProfile::glLogDebug("glNamedFramebufferParameteri({}, {}, {})", framebuffer, E2S(pname), param);
	apiHook.glNamedFramebufferParameteri(framebuffer, pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
{
	IRProfile::glLogDebug("glNamedFramebufferTexture({}, {}, {}, {})", framebuffer, E2S(attachment), texture, level);
	apiHook.glNamedFramebufferTexture(framebuffer, attachment, texture, level);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
	IRProfile::glLogDebug("glNamedFramebufferTextureLayer({}, {}, {}, {}, {})", framebuffer, E2S(attachment), texture, level, layer);
	apiHook.glNamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf)
{
	IRProfile::glLogDebug("glNamedFramebufferDrawBuffer({}, {})", framebuffer, E2S(buf));
	apiHook.glNamedFramebufferDrawBuffer(framebuffer, buf);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum* bufs)
{
	IRProfile::glLogDebug("glNamedFramebufferDrawBuffers({}, {}, {})", framebuffer, n, (const void*)(bufs));
	apiHook.glNamedFramebufferDrawBuffers(framebuffer, n, bufs);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum src)
{
	IRProfile::glLogDebug("glNamedFramebufferReadBuffer({}, {})", framebuffer, E2S(src));
	apiHook.glNamedFramebufferReadBuffer(framebuffer, src);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments)
{
	IRProfile::glLogDebug("glInvalidateNamedFramebufferData({}, {}, {})", framebuffer, numAttachments, (const void*)(attachments));
	apiHook.glInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height)
{
	IRProfile::glLogDebug("glInvalidateNamedFramebufferSubData({}, {}, {}, {}, {}, {}, {})", framebuffer, numAttachments, (const void*)(attachments), x, y, width, height);
	apiHook.glInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint* value)
{
	IRProfile::glLogDebug("glClearNamedFramebufferiv({}, {}, {}, {})", framebuffer, E2S(buffer), drawbuffer, (const void*)(value));
	apiHook.glClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint* value)
{
	IRProfile::glLogDebug("glClearNamedFramebufferuiv({}, {}, {}, {})", framebuffer, E2S(buffer), drawbuffer, (const void*)(value));
	apiHook.glClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat* value)
{
	IRProfile::glLogDebug("glClearNamedFramebufferfv({}, {}, {}, {})", framebuffer, E2S(buffer), drawbuffer, (const void*)(value));
	apiHook.glClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, const GLfloat depth, GLint stencil)
{
	IRProfile::glLogDebug("glClearNamedFramebufferfi({}, {}, {}, {})", framebuffer, E2S(buffer), depth, stencil);
	apiHook.glClearNamedFramebufferfi(framebuffer, buffer, depth, stencil);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
	IRProfile::glLogDebug("glBlitNamedFramebuffer({}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {})", readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (unsigned int)(mask), E2S(filter));
	apiHook.glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

GLenum GLTracer_glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target)
{
	IRProfile::glLogDebug("glCheckNamedFramebufferStatus({}, {})", framebuffer, E2S(target));
	GLenum const r = apiHook.glCheckNamedFramebufferStatus(framebuffer, target);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
	return r;
}

void GLTracer_glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint* param)
{
	IRProfile::glLogDebug("glGetNamedFramebufferParameteriv({}, {}, {})", framebuffer, E2S(pname), (void*)(param));
	apiHook.glGetNamedFramebufferParameteriv(framebuffer, pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params)
{
	IRProfile::glLogDebug("glGetNamedFramebufferAttachmentParameteriv({}, {}, {}, {})", framebuffer, E2S(attachment), E2S(pname), (void*)(params));
	apiHook.glGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCreateRenderbuffers(GLsizei n, GLuint* renderbuffers)
{
	IRProfile::glLogDebug("glCreateRenderbuffers({}, {})", n, (void*)(renderbuffers));
	apiHook.glCreateRenderbuffers(n, renderbuffers);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
{
	IRProfile::glLogDebug("glNamedRenderbufferStorage({}, {}, {}, {})", renderbuffer, E2S(internalformat), width, height);
	apiHook.glNamedRenderbufferStorage(renderbuffer, internalformat, width, height);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
	IRProfile::glLogDebug("glNamedRenderbufferStorageMultisample({}, {}, {}, {}, {})", renderbuffer, samples, E2S(internalformat), width, height);
	apiHook.glNamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint* params)
{
	IRProfile::glLogDebug("glGetNamedRenderbufferParameteriv({}, {}, {})", renderbuffer, E2S(pname), (void*)(params));
	apiHook.glGetNamedRenderbufferParameteriv(renderbuffer, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCreateTextures(GLenum target, GLsizei n, GLuint* textures)
{
	IRProfile::glLogDebug("glCreateTextures({}, {}, {})", E2S(target), n, (void*)(textures));
	apiHook.glCreateTextures(target, n, textures);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer)
{
	IRProfile::glLogDebug("glTextureBuffer({}, {}, {})", texture, E2S(internalformat), buffer);
	apiHook.glTextureBuffer(texture, internalformat, buffer);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizei size)
{
	IRProfile::glLogDebug("glTextureBufferRange({}, {}, {}, {}, {})", texture, E2S(internalformat), buffer, offset, size);
	apiHook.glTextureBufferRange(texture, internalformat, buffer, offset, size);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width)
{
	IRProfile::glLogDebug("glTextureStorage1D({}, {}, {}, {})", texture, levels, E2S(internalformat), width);
	apiHook.glTextureStorage1D(texture, levels, internalformat, width);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
	IRProfile::glLogDebug("glTextureStorage2D({}, {}, {}, {}, {})", texture, levels, E2S(internalformat), width, height);
	apiHook.glTextureStorage2D(texture, levels, internalformat, width, height);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
	IRProfile::glLogDebug("glTextureStorage3D({}, {}, {}, {}, {}, {})", texture, levels, E2S(internalformat), width, height, depth);
	apiHook.glTextureStorage3D(texture, levels, internalformat, width, height, depth);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
	IRProfile::glLogDebug("glTextureStorage2DMultisample({}, {}, {}, {}, {}, {})", texture, samples, E2S(internalformat), width, height, (unsigned int)(fixedsamplelocations));
	apiHook.glTextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
	IRProfile::glLogDebug("glTextureStorage3DMultisample({}, {}, {}, {}, {}, {}, {})", texture, samples, E2S(internalformat), width, height, depth, (unsigned int)(fixedsamplelocations));
	apiHook.glTextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels)
{
	IRProfile::glLogDebug("glTextureSubImage1D({}, {}, {}, {}, {}, {}, {})", texture, level, xoffset, width, E2S(format), E2S(type), pixels);
	apiHook.glTextureSubImage1D(texture, level, xoffset, width, format, type, pixels);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels)
{
	IRProfile::glLogDebug("glTextureSubImage2D({}, {}, {}, {}, {}, {}, {}, {}, {})", texture, level, xoffset, yoffset, width, height, E2S(format), E2S(type), pixels);
	apiHook.glTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels)
{
	IRProfile::glLogDebug("glTextureSubImage3D({}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {})", texture, level, xoffset, yoffset, zoffset, width, height, depth, E2S(format), E2S(type), pixels);
	apiHook.glTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data)
{
	IRProfile::glLogDebug("glCompressedTextureSubImage1D({}, {}, {}, {}, {}, {}, {})", texture, level, xoffset, width, E2S(format), imageSize, data);
	apiHook.glCompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data)
{
	IRProfile::glLogDebug("glCompressedTextureSubImage2D({}, {}, {}, {}, {}, {}, {}, {}, {})", texture, level, xoffset, yoffset, width, height, E2S(format), imageSize, data);
	apiHook.glCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data)
{
	IRProfile::glLogDebug("glCompressedTextureSubImage3D({}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {})", texture, level, xoffset, yoffset, zoffset, width, height, depth, E2S(format), imageSize, data);
	apiHook.glCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
	IRProfile::glLogDebug("glCopyTextureSubImage1D({}, {}, {}, {}, {}, {})", texture, level, xoffset, x, y, width);
	apiHook.glCopyTextureSubImage1D(texture, level, xoffset, x, y, width);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	IRProfile::glLogDebug("glCopyTextureSubImage2D({}, {}, {}, {}, {}, {}, {}, {})", texture, level, xoffset, yoffset, x, y, width, height);
	apiHook.glCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	IRProfile::glLogDebug("glCopyTextureSubImage3D({}, {}, {}, {}, {}, {}, {}, {}, {})", texture, level, xoffset, yoffset, zoffset, x, y, width, height);
	apiHook.glCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureParameterf(GLuint texture, GLenum pname, GLfloat param)
{
	IRProfile::glLogDebug("glTextureParameterf({}, {}, {})", texture, E2S(pname), param);
	apiHook.glTextureParameterf(texture, pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureParameterfv(GLuint texture, GLenum pname, const GLfloat* param)
{
	IRProfile::glLogDebug("glTextureParameterfv({}, {}, {})", texture, E2S(pname), (const void*)(param));
	apiHook.glTextureParameterfv(texture, pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureParameteri(GLuint texture, GLenum pname, GLint param)
{
	IRProfile::glLogDebug("glTextureParameteri({}, {}, {})", texture, E2S(pname), param);
	apiHook.glTextureParameteri(texture, pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureParameterIiv(GLuint texture, GLenum pname, const GLint* params)
{
	IRProfile::glLogDebug("glTextureParameterIiv({}, {}, {})", texture, E2S(pname), (const void*)(params));
	apiHook.glTextureParameterIiv(texture, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureParameterIuiv(GLuint texture, GLenum pname, const GLuint* params)
{
	IRProfile::glLogDebug("glTextureParameterIuiv({}, {}, {})", texture, E2S(pname), (const void*)(params));
	apiHook.glTextureParameterIuiv(texture, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glTextureParameteriv(GLuint texture, GLenum pname, const GLint* param)
{
	IRProfile::glLogDebug("glTextureParameteriv({}, {}, {})", texture, E2S(pname), (const void*)(param));
	apiHook.glTextureParameteriv(texture, pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGenerateTextureMipmap(GLuint texture)
{
	IRProfile::glLogDebug("glGenerateTextureMipmap({})", texture);
	apiHook.glGenerateTextureMipmap(texture);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glBindTextureUnit(GLuint unit, GLuint texture)
{
	IRProfile::glLogDebug("glBindTextureUnit({}, {})", unit, texture);
	apiHook.glBindTextureUnit(unit, texture);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* pixels)
{
	IRProfile::glLogDebug("glGetTextureImage({}, {}, {}, {}, {}, {})", texture, level, E2S(format), E2S(type), bufSize, pixels);
	apiHook.glGetTextureImage(texture, level, format, type, bufSize, pixels);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void* pixels)
{
	IRProfile::glLogDebug("glGetCompressedTextureImage({}, {}, {}, {})", texture, level, bufSize, pixels);
	apiHook.glGetCompressedTextureImage(texture, level, bufSize, pixels);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat* params)
{
	IRProfile::glLogDebug("glGetTextureLevelParameterfv({}, {}, {}, {})", texture, level, E2S(pname), (void*)(params));
	apiHook.glGetTextureLevelParameterfv(texture, level, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint* params)
{
	IRProfile::glLogDebug("glGetTextureLevelParameteriv({}, {}, {}, {})", texture, level, E2S(pname), (void*)(params));
	apiHook.glGetTextureLevelParameteriv(texture, level, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat* params)
{
	IRProfile::glLogDebug("glGetTextureParameterfv({}, {}, {})", texture, E2S(pname), (void*)(params));
	apiHook.glGetTextureParameterfv(texture, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint* params)
{
	IRProfile::glLogDebug("glGetTextureParameterIiv({}, {}, {})", texture, E2S(pname), (void*)(params));
	apiHook.glGetTextureParameterIiv(texture, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint* params)
{
	IRProfile::glLogDebug("glGetTextureParameterIuiv({}, {}, {})", texture, E2S(pname), (void*)(params));
	apiHook.glGetTextureParameterIuiv(texture, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetTextureParameteriv(GLuint texture, GLenum pname, GLint* params)
{
	IRProfile::glLogDebug("glGetTextureParameteriv({}, {}, {})", texture, E2S(pname), (void*)(params));
	apiHook.glGetTextureParameteriv(texture, pname, params);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCreateVertexArrays(GLsizei n, GLuint* arrays)
{
	IRProfile::glLogDebug("glCreateVertexArrays({}, {})", n, (void*)(arrays));
	apiHook.glCreateVertexArrays(n, arrays);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glDisableVertexArrayAttrib(GLuint vaobj, GLuint index)
{
	IRProfile::glLogDebug("glDisableVertexArrayAttrib({}, {})", vaobj, index);
	apiHook.glDisableVertexArrayAttrib(vaobj, index);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glEnableVertexArrayAttrib(GLuint vaobj, GLuint index)
{
	IRProfile::glLogDebug("glEnableVertexArrayAttrib({}, {})", vaobj, index);
	apiHook.glEnableVertexArrayAttrib(vaobj, index);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer)
{
	IRProfile::glLogDebug("glVertexArrayElementBuffer({}, {})", vaobj, buffer);
	apiHook.glVertexArrayElementBuffer(vaobj, buffer);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
	IRProfile::glLogDebug("glVertexArrayVertexBuffer({}, {}, {}, {}, {})", vaobj, bindingindex, buffer, offset, stride);
	apiHook.glVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizei* strides)
{
	IRProfile::glLogDebug("glVertexArrayVertexBuffers({}, {}, {}, {}, {}, {})", vaobj, first, count, (const void*)(buffers), (const void*)(offsets), (const void*)(strides));
	apiHook.glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex)
{
	IRProfile::glLogDebug("glVertexArrayAttribBinding({}, {}, {})", vaobj, attribindex, bindingindex);
	apiHook.glVertexArrayAttribBinding(vaobj, attribindex, bindingindex);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
	IRProfile::glLogDebug("glVertexArrayAttribFormat({}, {}, {}, {}, {}, {})", vaobj, attribindex, size, E2S(type), (unsigned int)(normalized), relativeoffset);
	apiHook.glVertexArrayAttribFormat(vaobj, attribindex, size, type, normalized, relativeoffset);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
	IRProfile::glLogDebug("glVertexArrayAttribIFormat({}, {}, {}, {}, {})", vaobj, attribindex, size, E2S(type), relativeoffset);
	apiHook.glVertexArrayAttribIFormat(vaobj, attribindex, size, type, relativeoffset);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
	IRProfile::glLogDebug("glVertexArrayAttribLFormat({}, {}, {}, {}, {})", vaobj, attribindex, size, E2S(type), relativeoffset);
	apiHook.glVertexArrayAttribLFormat(vaobj, attribindex, size, type, relativeoffset);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor)
{
	IRProfile::glLogDebug("glVertexArrayBindingDivisor({}, {}, {})", vaobj, bindingindex, divisor);
	apiHook.glVertexArrayBindingDivisor(vaobj, bindingindex, divisor);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint* param)
{
	IRProfile::glLogDebug("glGetVertexArrayiv({}, {}, {})", vaobj, E2S(pname), (void*)(param));
	apiHook.glGetVertexArrayiv(vaobj, pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint* param)
{
	IRProfile::glLogDebug("glGetVertexArrayIndexediv({}, {}, {}, {})", vaobj, index, E2S(pname), (void*)(param));
	apiHook.glGetVertexArrayIndexediv(vaobj, index, pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64* param)
{
	IRProfile::glLogDebug("glGetVertexArrayIndexed64iv({}, {}, {}, {})", vaobj, index, E2S(pname), (void*)(param));
	apiHook.glGetVertexArrayIndexed64iv(vaobj, index, pname, param);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCreateSamplers(GLsizei n, GLuint* samplers)
{
	IRProfile::glLogDebug("glCreateSamplers({}, {})", n, (void*)(samplers));
	apiHook.glCreateSamplers(n, samplers);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCreateProgramPipelines(GLsizei n, GLuint* pipelines)
{
	IRProfile::glLogDebug("glCreateProgramPipelines({}, {})", n, (void*)(pipelines));
	apiHook.glCreateProgramPipelines(n, pipelines);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

void GLTracer_glCreateQueries(GLenum target, GLsizei n, GLuint* ids)
{
	IRProfile::glLogDebug("glCreateQueries({}, {}, {})", E2S(target), n, (void*)(ids));
	apiHook.glCreateQueries(target, n, ids);
	GLenum glError = apiHook.glGetError();
	IRProfile::glAssert(glError == GL_NO_ERROR, E2S(glError));
}

#define INJECT(S) api->S = &GLTracer_##S;

void InjectAPITracer4(GL4API* api)
{
	apiHook = *api;
	INJECT(glActiveTexture);
	INJECT(glAttachShader);
	INJECT(glBeginQuery);
	INJECT(glBindAttribLocation);
	INJECT(glBindBuffer);
	INJECT(glBindBufferBase);
	INJECT(glBindBufferRange);
	INJECT(glBindFragDataLocation);
	INJECT(glBindFramebuffer);
	INJECT(glBindTextureUnit);
	INJECT(glBindTextures);
	INJECT(glBindVertexArray);
	INJECT(glBlendFunc);
	INJECT(glBlitNamedFramebuffer);
	INJECT(glBufferData);
	INJECT(glBufferSubData);
	INJECT(glCheckFramebufferStatus);
	INJECT(glCheckNamedFramebufferStatus);
	INJECT(glClear);
	INJECT(glClearColor);
	INJECT(glClearDepth);
	INJECT(glClearNamedBufferData);
	INJECT(glClearNamedBufferSubData);
	INJECT(glClearNamedFramebufferfi);
	INJECT(glClearNamedFramebufferfv);
	INJECT(glClearNamedFramebufferiv);
	INJECT(glClearNamedFramebufferuiv);
	INJECT(glClearStencil);
	INJECT(glColorMask);
	INJECT(glCompileShader);
	INJECT(glCompressedTexImage2D);
	INJECT(glCompressedTexImage3D);
	INJECT(glCompressedTextureSubImage1D);
	INJECT(glCompressedTextureSubImage2D);
	INJECT(glCompressedTextureSubImage3D);
	INJECT(glCopyNamedBufferSubData);
	INJECT(glCopyTextureSubImage1D);
	INJECT(glCopyTextureSubImage2D);
	INJECT(glCopyTextureSubImage3D);
	INJECT(glCreateBuffers);
	INJECT(glCreateFramebuffers);
	INJECT(glCreateProgram);
	INJECT(glCreateProgramPipelines);
	INJECT(glCreateQueries);
	INJECT(glCreateRenderbuffers);
	INJECT(glCreateSamplers);
	INJECT(glCreateShader);
	INJECT(glCreateTextures);
	INJECT(glCreateTransformFeedbacks);
	INJECT(glCreateVertexArrays);
	INJECT(glCullFace);
	INJECT(glDeleteBuffers);
	INJECT(glDeleteFramebuffers);
	INJECT(glDeleteProgram);
	INJECT(glDeleteQueries);
	INJECT(glDeleteShader);
	INJECT(glDeleteTextures);
	INJECT(glDeleteVertexArrays);
	INJECT(glDepthFunc);
	INJECT(glDepthMask);
	INJECT(glDisable);
	INJECT(glDisableVertexArrayAttrib);
	INJECT(glDisableVertexAttribArray);
	INJECT(glDisablei);
	INJECT(glDrawArrays);
	INJECT(glDrawArraysInstanced);
	INJECT(glDrawBuffers);
	INJECT(glDrawElements);
	INJECT(glDrawElementsInstanced);
	INJECT(glEnable);
	INJECT(glEnableVertexArrayAttrib);
	INJECT(glEnableVertexAttribArray);
	INJECT(glEnablei);
	INJECT(glEndQuery);
	INJECT(glFinish);
	INJECT(glFlush);
	INJECT(glFlushMappedNamedBufferRange);
	INJECT(glFramebufferTexture2D);
	INJECT(glFramebufferTexture3D);
	INJECT(glGenBuffers);
	INJECT(glGenFramebuffers);
	INJECT(glGenQueries);
	INJECT(glGenTextures);
	INJECT(glGenVertexArrays);
	INJECT(glGenerateMipmap);
	INJECT(glGenerateTextureMipmap);
	INJECT(glGetActiveAttrib);
	INJECT(glGetActiveSubroutineName);
	INJECT(glGetActiveSubroutineUniformiv);
	INJECT(glGetActiveUniform);
	INJECT(glGetActiveUniformBlockiv);
	INJECT(glGetAttribLocation);
	INJECT(glGetCompressedTexImage);
	INJECT(glGetCompressedTextureImage);
	INJECT(glGetIntegerv);
	INJECT(glGetNamedBufferParameteri64v);
	INJECT(glGetNamedBufferParameteriv);
	INJECT(glGetNamedBufferPointerv);
	INJECT(glGetNamedBufferSubData);
	INJECT(glGetNamedFramebufferAttachmentParameteriv);
	INJECT(glGetNamedFramebufferParameteriv);
	INJECT(glGetNamedRenderbufferParameteriv);
	INJECT(glGetProgramBinary);
	INJECT(glGetProgramInfoLog);
	INJECT(glGetProgramStageiv);
	INJECT(glGetProgramiv);
	INJECT(glGetQueryObjectiv);
	INJECT(glGetQueryObjectui64v);
	INJECT(glGetShaderInfoLog);
	INJECT(glGetShaderiv);
	INJECT(glGetSubroutineIndex);
	INJECT(glGetSubroutineUniformLocation);
	INJECT(glGetTexImage);
	INJECT(glGetTexLevelParameteriv);
	INJECT(glGetTextureImage);
	INJECT(glGetTextureLevelParameterfv);
	INJECT(glGetTextureLevelParameteriv);
	INJECT(glGetTextureParameterIiv);
	INJECT(glGetTextureParameterIuiv);
	INJECT(glGetTextureParameterfv);
	INJECT(glGetTextureParameteriv);
	INJECT(glGetTransformFeedbacki64_v);
	INJECT(glGetTransformFeedbacki_v);
	INJECT(glGetTransformFeedbackiv);
	INJECT(glGetUniformLocation);
	INJECT(glGetVertexArrayIndexed64iv);
	INJECT(glGetVertexArrayIndexediv);
	INJECT(glGetVertexArrayiv);
	INJECT(glInvalidateNamedFramebufferData);
	INJECT(glInvalidateNamedFramebufferSubData);
	INJECT(glIsProgram);
	INJECT(glIsShader);
	INJECT(glLinkProgram);
	INJECT(glMapNamedBuffer);
	INJECT(glMapNamedBufferRange);
	INJECT(glNamedBufferData);
	INJECT(glNamedBufferStorage);
	INJECT(glNamedBufferSubData);
	INJECT(glNamedFramebufferDrawBuffer);
	INJECT(glNamedFramebufferDrawBuffers);
	INJECT(glNamedFramebufferParameteri);
	INJECT(glNamedFramebufferReadBuffer);
	INJECT(glNamedFramebufferRenderbuffer);
	INJECT(glNamedFramebufferTexture);
	INJECT(glNamedFramebufferTextureLayer);
	INJECT(glNamedRenderbufferStorage);
	INJECT(glNamedRenderbufferStorageMultisample);
	INJECT(glPatchParameteri);
	INJECT(glPixelStorei);
	INJECT(glPolygonMode);
	INJECT(glProgramBinary);
	INJECT(glProgramParameteri);
	INJECT(glProgramUniform1f);
	INJECT(glProgramUniform1i);
	INJECT(glProgramUniform2fv);
	INJECT(glProgramUniform2iv);
	INJECT(glProgramUniform3fv);
	INJECT(glProgramUniform3iv);
	INJECT(glProgramUniform4fv);
	INJECT(glProgramUniform4iv);
	INJECT(glReadBuffer);
	INJECT(glReadPixels);
	INJECT(glScissor);
	INJECT(glShaderSource);
	INJECT(glTexImage2D);
	INJECT(glTexImage3D);
	INJECT(glTexParameterf);
	INJECT(glTexParameterfv);
	INJECT(glTexParameteri);
	INJECT(glTexParameteriv);
	INJECT(glTexSubImage2D);
	INJECT(glTextureBuffer);
	INJECT(glTextureBufferRange);
	INJECT(glTextureParameterIiv);
	INJECT(glTextureParameterIuiv);
	INJECT(glTextureParameterf);
	INJECT(glTextureParameterfv);
	INJECT(glTextureParameteri);
	INJECT(glTextureParameteriv);
	INJECT(glTextureStorage1D);
	INJECT(glTextureStorage2D);
	INJECT(glTextureStorage2DMultisample);
	INJECT(glTextureStorage3D);
	INJECT(glTextureStorage3DMultisample);
	INJECT(glTextureSubImage1D);
	INJECT(glTextureSubImage2D);
	INJECT(glTextureSubImage3D);
	INJECT(glTransformFeedbackBufferBase);
	INJECT(glTransformFeedbackBufferRange);
	INJECT(glUniform1f);
	INJECT(glUniform1fv);
	INJECT(glUniform1i);
	INJECT(glUniform1iv);
	INJECT(glUniform3fv);
	INJECT(glUniform4fv);
	INJECT(glUniformBlockBinding);
	INJECT(glUniformMatrix3fv);
	INJECT(glUniformMatrix4fv);
	INJECT(glUniformSubroutinesuiv);
	INJECT(glUnmapNamedBuffer);
	INJECT(glUseProgram);
	INJECT(glValidateProgram);
	INJECT(glVertexArrayAttribBinding);
	INJECT(glVertexArrayAttribFormat);
	INJECT(glVertexArrayAttribIFormat);
	INJECT(glVertexArrayAttribLFormat);
	INJECT(glVertexArrayBindingDivisor);
	INJECT(glVertexArrayElementBuffer);
	INJECT(glVertexArrayVertexBuffer);
	INJECT(glVertexArrayVertexBuffers);
	INJECT(glVertexAttribPointer);
	INJECT(glViewport);
}

#define LOAD_GL_FUNC(func) api->func = ( decltype(api->func) )GetGLProc(#func);

void GetAPI4(GL4API* api, PFNGETGLPROC GetGLProc)
{
	LOAD_GL_FUNC(glActiveTexture);
	LOAD_GL_FUNC(glAttachShader);
	LOAD_GL_FUNC(glBeginQuery);
	LOAD_GL_FUNC(glBindAttribLocation);
	LOAD_GL_FUNC(glBindBuffer);
	LOAD_GL_FUNC(glBindBufferBase);
	LOAD_GL_FUNC(glBindBufferRange);
	LOAD_GL_FUNC(glBindFragDataLocation);
	LOAD_GL_FUNC(glBindFramebuffer);
	LOAD_GL_FUNC(glBindTextureUnit);
	LOAD_GL_FUNC(glBindTextures);
	LOAD_GL_FUNC(glBindVertexArray);
	LOAD_GL_FUNC(glBlendFunc);
	LOAD_GL_FUNC(glBlitNamedFramebuffer);
	LOAD_GL_FUNC(glBufferData);
	LOAD_GL_FUNC(glBufferSubData);
	LOAD_GL_FUNC(glCheckFramebufferStatus);
	LOAD_GL_FUNC(glCheckNamedFramebufferStatus);
	LOAD_GL_FUNC(glClear);
	LOAD_GL_FUNC(glClearColor);
	LOAD_GL_FUNC(glClearDepth);
	LOAD_GL_FUNC(glClearNamedBufferData);
	LOAD_GL_FUNC(glClearNamedBufferSubData);
	LOAD_GL_FUNC(glClearNamedFramebufferfi);
	LOAD_GL_FUNC(glClearNamedFramebufferfv);
	LOAD_GL_FUNC(glClearNamedFramebufferiv);
	LOAD_GL_FUNC(glClearNamedFramebufferuiv);
	LOAD_GL_FUNC(glClearStencil);
	LOAD_GL_FUNC(glColorMask);
	LOAD_GL_FUNC(glCompileShader);
	LOAD_GL_FUNC(glCompressedTexImage2D);
	LOAD_GL_FUNC(glCompressedTexImage3D);
	LOAD_GL_FUNC(glCompressedTextureSubImage1D);
	LOAD_GL_FUNC(glCompressedTextureSubImage2D);
	LOAD_GL_FUNC(glCompressedTextureSubImage3D);
	LOAD_GL_FUNC(glCopyNamedBufferSubData);
	LOAD_GL_FUNC(glCopyTextureSubImage1D);
	LOAD_GL_FUNC(glCopyTextureSubImage2D);
	LOAD_GL_FUNC(glCopyTextureSubImage3D);
	LOAD_GL_FUNC(glCreateBuffers);
	LOAD_GL_FUNC(glCreateFramebuffers);
	LOAD_GL_FUNC(glCreateProgram);
	LOAD_GL_FUNC(glCreateProgramPipelines);
	LOAD_GL_FUNC(glCreateQueries);
	LOAD_GL_FUNC(glCreateRenderbuffers);
	LOAD_GL_FUNC(glCreateSamplers);
	LOAD_GL_FUNC(glCreateShader);
	LOAD_GL_FUNC(glCreateTextures);
	LOAD_GL_FUNC(glCreateTransformFeedbacks);
	LOAD_GL_FUNC(glCreateVertexArrays);
	LOAD_GL_FUNC(glCullFace);
	LOAD_GL_FUNC(glDeleteBuffers);
	LOAD_GL_FUNC(glDeleteFramebuffers);
	LOAD_GL_FUNC(glDeleteProgram);
	LOAD_GL_FUNC(glDeleteQueries);
	LOAD_GL_FUNC(glDeleteShader);
	LOAD_GL_FUNC(glDeleteTextures);
	LOAD_GL_FUNC(glDeleteVertexArrays);
	LOAD_GL_FUNC(glDepthFunc);
	LOAD_GL_FUNC(glDepthMask);
	LOAD_GL_FUNC(glDisable);
	LOAD_GL_FUNC(glDisableVertexArrayAttrib);
	LOAD_GL_FUNC(glDisableVertexAttribArray);
	LOAD_GL_FUNC(glDisablei);
	LOAD_GL_FUNC(glDrawArrays);
	LOAD_GL_FUNC(glDrawArraysInstanced);
	LOAD_GL_FUNC(glDrawBuffers);
	LOAD_GL_FUNC(glDrawElements);
	LOAD_GL_FUNC(glDrawElementsInstanced);
	LOAD_GL_FUNC(glEnable);
	LOAD_GL_FUNC(glEnableVertexArrayAttrib);
	LOAD_GL_FUNC(glEnableVertexAttribArray);
	LOAD_GL_FUNC(glEnablei);
	LOAD_GL_FUNC(glEndQuery);
	LOAD_GL_FUNC(glFinish);
	LOAD_GL_FUNC(glFlush);
	LOAD_GL_FUNC(glFlushMappedNamedBufferRange);
	LOAD_GL_FUNC(glFramebufferTexture2D);
	LOAD_GL_FUNC(glFramebufferTexture3D);
	LOAD_GL_FUNC(glGenBuffers);
	LOAD_GL_FUNC(glGenFramebuffers);
	LOAD_GL_FUNC(glGenQueries);
	LOAD_GL_FUNC(glGenTextures);
	LOAD_GL_FUNC(glGenVertexArrays);
	LOAD_GL_FUNC(glGenerateMipmap);
	LOAD_GL_FUNC(glGenerateTextureMipmap);
	LOAD_GL_FUNC(glGetActiveAttrib);
	LOAD_GL_FUNC(glGetActiveSubroutineName);
	LOAD_GL_FUNC(glGetActiveSubroutineUniformiv);
	LOAD_GL_FUNC(glGetActiveUniform);
	LOAD_GL_FUNC(glGetActiveUniformBlockiv);
	LOAD_GL_FUNC(glGetAttribLocation);
	LOAD_GL_FUNC(glGetCompressedTexImage);
	LOAD_GL_FUNC(glGetCompressedTextureImage);
	LOAD_GL_FUNC(glGetError);
	LOAD_GL_FUNC(glGetIntegerv);
	LOAD_GL_FUNC(glGetNamedBufferParameteri64v);
	LOAD_GL_FUNC(glGetNamedBufferParameteriv);
	LOAD_GL_FUNC(glGetNamedBufferPointerv);
	LOAD_GL_FUNC(glGetNamedBufferSubData);
	LOAD_GL_FUNC(glGetNamedFramebufferAttachmentParameteriv);
	LOAD_GL_FUNC(glGetNamedFramebufferParameteriv);
	LOAD_GL_FUNC(glGetNamedRenderbufferParameteriv);
	LOAD_GL_FUNC(glGetProgramBinary);
	LOAD_GL_FUNC(glGetProgramInfoLog);
	LOAD_GL_FUNC(glGetProgramStageiv);
	LOAD_GL_FUNC(glGetProgramiv);
	LOAD_GL_FUNC(glGetQueryObjectiv);
	LOAD_GL_FUNC(glGetQueryObjectui64v);
	LOAD_GL_FUNC(glGetShaderInfoLog);
	LOAD_GL_FUNC(glGetShaderiv);
	LOAD_GL_FUNC(glGetSubroutineIndex);
	LOAD_GL_FUNC(glGetSubroutineUniformLocation);
	LOAD_GL_FUNC(glGetTexImage);
	LOAD_GL_FUNC(glGetTexLevelParameteriv);
	LOAD_GL_FUNC(glGetTextureImage);
	LOAD_GL_FUNC(glGetTextureLevelParameterfv);
	LOAD_GL_FUNC(glGetTextureLevelParameteriv);
	LOAD_GL_FUNC(glGetTextureParameterIiv);
	LOAD_GL_FUNC(glGetTextureParameterIuiv);
	LOAD_GL_FUNC(glGetTextureParameterfv);
	LOAD_GL_FUNC(glGetTextureParameteriv);
	LOAD_GL_FUNC(glGetTransformFeedbacki64_v);
	LOAD_GL_FUNC(glGetTransformFeedbacki_v);
	LOAD_GL_FUNC(glGetTransformFeedbackiv);
	LOAD_GL_FUNC(glGetUniformLocation);
	LOAD_GL_FUNC(glGetVertexArrayIndexed64iv);
	LOAD_GL_FUNC(glGetVertexArrayIndexediv);
	LOAD_GL_FUNC(glGetVertexArrayiv);
	LOAD_GL_FUNC(glInvalidateNamedFramebufferData);
	LOAD_GL_FUNC(glInvalidateNamedFramebufferSubData);
	LOAD_GL_FUNC(glIsProgram);
	LOAD_GL_FUNC(glIsShader);
	LOAD_GL_FUNC(glLinkProgram);
	LOAD_GL_FUNC(glMapNamedBuffer);
	LOAD_GL_FUNC(glMapNamedBufferRange);
	LOAD_GL_FUNC(glNamedBufferData);
	LOAD_GL_FUNC(glNamedBufferStorage);
	LOAD_GL_FUNC(glNamedBufferSubData);
	LOAD_GL_FUNC(glNamedFramebufferDrawBuffer);
	LOAD_GL_FUNC(glNamedFramebufferDrawBuffers);
	LOAD_GL_FUNC(glNamedFramebufferParameteri);
	LOAD_GL_FUNC(glNamedFramebufferReadBuffer);
	LOAD_GL_FUNC(glNamedFramebufferRenderbuffer);
	LOAD_GL_FUNC(glNamedFramebufferTexture);
	LOAD_GL_FUNC(glNamedFramebufferTextureLayer);
	LOAD_GL_FUNC(glNamedRenderbufferStorage);
	LOAD_GL_FUNC(glNamedRenderbufferStorageMultisample);
	LOAD_GL_FUNC(glPatchParameteri);
	LOAD_GL_FUNC(glPixelStorei);
	LOAD_GL_FUNC(glPolygonMode);
	LOAD_GL_FUNC(glProgramBinary);
	LOAD_GL_FUNC(glProgramParameteri);
	LOAD_GL_FUNC(glProgramUniform1f);
	LOAD_GL_FUNC(glProgramUniform1i);
	LOAD_GL_FUNC(glProgramUniform2fv);
	LOAD_GL_FUNC(glProgramUniform2iv);
	LOAD_GL_FUNC(glProgramUniform3fv);
	LOAD_GL_FUNC(glProgramUniform3iv);
	LOAD_GL_FUNC(glProgramUniform4fv);
	LOAD_GL_FUNC(glProgramUniform4iv);
	LOAD_GL_FUNC(glReadBuffer);
	LOAD_GL_FUNC(glReadPixels);
	LOAD_GL_FUNC(glScissor);
	LOAD_GL_FUNC(glShaderSource);
	LOAD_GL_FUNC(glTexImage2D);
	LOAD_GL_FUNC(glTexImage3D);
	LOAD_GL_FUNC(glTexParameterf);
	LOAD_GL_FUNC(glTexParameterfv);
	LOAD_GL_FUNC(glTexParameteri);
	LOAD_GL_FUNC(glTexParameteriv);
	LOAD_GL_FUNC(glTexSubImage2D);
	LOAD_GL_FUNC(glTextureBuffer);
	LOAD_GL_FUNC(glTextureBufferRange);
	LOAD_GL_FUNC(glTextureParameterIiv);
	LOAD_GL_FUNC(glTextureParameterIuiv);
	LOAD_GL_FUNC(glTextureParameterf);
	LOAD_GL_FUNC(glTextureParameterfv);
	LOAD_GL_FUNC(glTextureParameteri);
	LOAD_GL_FUNC(glTextureParameteriv);
	LOAD_GL_FUNC(glTextureStorage1D);
	LOAD_GL_FUNC(glTextureStorage2D);
	LOAD_GL_FUNC(glTextureStorage2DMultisample);
	LOAD_GL_FUNC(glTextureStorage3D);
	LOAD_GL_FUNC(glTextureStorage3DMultisample);
	LOAD_GL_FUNC(glTextureSubImage1D);
	LOAD_GL_FUNC(glTextureSubImage2D);
	LOAD_GL_FUNC(glTextureSubImage3D);
	LOAD_GL_FUNC(glTransformFeedbackBufferBase);
	LOAD_GL_FUNC(glTransformFeedbackBufferRange);
	LOAD_GL_FUNC(glUniform1f);
	LOAD_GL_FUNC(glUniform1fv);
	LOAD_GL_FUNC(glUniform1i);
	LOAD_GL_FUNC(glUniform1iv);
	LOAD_GL_FUNC(glUniform3fv);
	LOAD_GL_FUNC(glUniform4fv);
	LOAD_GL_FUNC(glUniformBlockBinding);
	LOAD_GL_FUNC(glUniformMatrix3fv);
	LOAD_GL_FUNC(glUniformMatrix4fv);
	LOAD_GL_FUNC(glUniformSubroutinesuiv);
	LOAD_GL_FUNC(glUnmapNamedBuffer);
	LOAD_GL_FUNC(glUseProgram);
	LOAD_GL_FUNC(glValidateProgram);
	LOAD_GL_FUNC(glVertexArrayAttribBinding);
	LOAD_GL_FUNC(glVertexArrayAttribFormat);
	LOAD_GL_FUNC(glVertexArrayAttribIFormat);
	LOAD_GL_FUNC(glVertexArrayAttribLFormat);
	LOAD_GL_FUNC(glVertexArrayBindingDivisor);
	LOAD_GL_FUNC(glVertexArrayElementBuffer);
	LOAD_GL_FUNC(glVertexArrayVertexBuffer);
	LOAD_GL_FUNC(glVertexArrayVertexBuffers);
	LOAD_GL_FUNC(glVertexAttribPointer);
	LOAD_GL_FUNC(glViewport);
}

